{"backend_state":"ready","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_backend_state":1742459405930,"last_ipynb_save":1742459405919,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.10.12"}},"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"1f464c","input":"from berlekampmassey import bm\n\n\npoly = list(bm('10001010001010001010'))[-1]\nprint(\"[*] Recovering secret key  : \",poly[::-1])  # The recovered polynomial is our key","pos":19,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"38d028","input":"def shift_and_yield(iv):\n    while iv:\n        ot = 1 & iv # save the rightmost bit\n        iv >>= 1 # shift\n        yield ot","pos":1,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"42bff9","input":"key = lfsr_generate(seed, mask, samples)\nkey_str = ''.join(str(x) for x, _ in key)\nkey_hex = hex(int(key_str, 2))[2:]","pos":8,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"48c0f0","input":"shift_and_print(int(hex(0x63), 16))\n","pos":2,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"4c6808","input":"key_hex = # Get the hexa value of the key\nkey_hex","pos":15,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"5d3c1a","input":"cipher = encrypt(plain, key_hex)\nprint(\"[x] Ciphertext = \", cipher.encode('utf-8').hex())\n# based on the above initial setting the output of hexa value of the encoded cipher should be --> c3b947c38fc3af5cc38ac3a346c385c2aa46c387c3bd","pos":16,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"62d720","input":"plain = 'something new'     # plaintext entered as string, e.g. 'something new'\nsecret_seed = '0001'        # secret initial seed\nmask = '0101'               # e.g. 101 means --> x^2 + 1\nsamples = len(plain) * 8    # required number of random bits --> number of characters in plaintext multiplied by 8","pos":13,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"6cf4f0","input":"def shift_and_print(iv):\n    while iv:\n        ot = 1 & iv # save the rightmost bit\n        iv >>= 1 # shift\n        print(ot)","pos":0,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"6e7605","input":"def encrypt(plain, key):\n    # Your code Here\n    # For encryption take two digits of the key (entered as hexa), convert them to integer, then XOR them with the ascii code of charachter, convert the result back to symnbol, to be repeated for all string\n    return result","pos":11,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"7d9ebc","input":"def decrypt(cipher, key):\n    # Your code here\n    # reverse the encryption process. The code is identical to the encryption part.\n    return result","pos":12,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"b20e25","input":"\nre_plain = decrypt(cipher, key_hex)\nprint(\"[x] Recovered plaintext = \", re_plain)","pos":17,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"bd6812","input":"shift_and_print(int('1001110', 2))\n","pos":3,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"c40d4b","input":"seed = '0001'       # secret initial seed\nmask = '0101'       # e.g. 101 means --> x^2 + 1\nsamples = 20        # required number of random bits","pos":7,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"c9905e","input":"key = lfsr_generate(secret_seed, mask, samples)\nkey_str = # Convert the key to a sequence of binary bits\n# based on the above initial setting the output of key_str should be --> 10001010001010001010001010001010001010001010001010001010001010001010001010001010001010001010001010001010\nkey_str","pos":14,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"cc3353","input":"def lfsr_generate(seed, mask, n):\n    seed_int = int(seed, 2)\n    mask_int = int(mask, 2)\n    nbits = len(seed)\n\n    state = seed_int\n    while n > 0:\n        output = # get the most right bit\n\n        _mask, _state, new_bit = # store the values of mask_int and state, also set the new bit to zero, which will be later modified based on the mask and seed value\n        while _mask:\n            new_bit # bit by bit xor with the current state, based on the mask\n            _mask # shift to the right\n            _state # shift to the right\n\n        state = # Shift to the right by one, and put (concatenate) the new bit in the msb\n\n\n        yield output, state\n        n -= 1","pos":6,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"dec61c","input":"print(\"[x] output lfsr sequence = \", key_str)\n# For the above initial setting the output should be --> [x] output lfsr sequence =  10001010001010001010\nassert key_str == '10001010001010001010'","pos":9,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"df7733","input":"","pos":20,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"f87b2d","input":"print('Output in one line = ',\n      ''.join(str(output) for output in shift_and_yield(int('1101001', 2))))","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"023b91","input":"## ChaCha20\n\n","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"2142dd","input":"## Encryption and Decryption using LFSR\n\n","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"7bc224","input":"## Linear Feedback Shift Register\n\n","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"d34c34","input":"## Cracking LFSR\n\n","pos":18,"type":"cell"}
{"id":"85474d","input":"from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport os\n\ndef chacha20_encrypt(plaintext, key, nonce):\n    cipher = Cipher(algorithms.ChaCha20(key, nonce), mode=None, backend=default_backend())\n    encryptor = cipher.encryptor()\n    return encryptor.update(plaintext)\n\ndef chacha20_decrypt(ciphertext, key, nonce):\n    cipher = Cipher(algorithms.ChaCha20(key, nonce), mode=None, backend=default_backend())\n    decryptor = cipher.decryptor()\n    return decryptor.update(ciphertext)\n\n# Generate a random 32-byte key and 16-byte nonce\nkey = os.urandom(32)  # 256-bit key\nnonce = os.urandom(16)  # 128-bit nonce\n\n# Example usage\nplaintext = b\"Secret message\"\nciphertext = chacha20_encrypt(plaintext, key, nonce)\ndecrypted = chacha20_decrypt(ciphertext, key, nonce)\n\nprint(f\"Plaintext: {plaintext}\")\nprint(f\"Ciphertext: {ciphertext.hex()}\")\nprint(f\"Decrypted: {decrypted}\")","pos":22,"type":"cell"}
{"id":0,"time":1742455943043,"type":"user"}
{"last_load":1742455941965,"type":"file"}